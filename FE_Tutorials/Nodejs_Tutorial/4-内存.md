## 内存

我们知道，内存是 CPU 能直接寻址的储存空间；内存的作用就是存储信息；
操作系统中，进程是分配内存的最小单位，及一个进程内是共享内存的；
对于大多数高级编程语言，应用程序都需要开发手动释放内存；而对于 Node 开发者，内存的释放是通过 V8 自己来释放的，准确来说是通过 V8 的垃圾回收机制；

所以，在 Node 中我们谈内存之前，我们先来了解下什么是 V8 的垃圾回收？

> 在./V8/README.md 中有详细说明垃圾回收的；
> 又上我们了解了垃圾回收机制，我们再看 V8 内存分配；

1. V8 的内存限制
   在 V8 分配和管理内存的规则中，对内存分配的限制是：

   - 在 64 位操作系统下，最多能使用 1.4GB 的内存，在 32 位下，最多能使用 0.7GB 内存；(ps：也可以理解这是分配给老生代的)

   那为什么会有这样的限制呢？

   - 从表面上看：V8 最早服务于客户端程序，而客户端程序对内存的要求并不高，没有大内存要求；并且可以通过合理的内存请求分配，控制内存大小；
   - 从本质上看：我们知道 V8 在分配内存后，是自身自动释放内存的---这既是垃圾回收机制；
     我们看垃圾回收机制，分新生代和老生代；新生代目标是快速的进行分配和清理，一份为二，用空间换时间，所以新生代不宜过大，不然每次需要花费的时间过长，影响新生代回收效率，阻塞 js 的执行而影响性能和体验；而老生代虽然可以存储大量数据，但是老生代也需要一定时间清理数据；老生代是用的标记清除和整理；要标记，整理都需要查找目前存储的所有资源，需要内存分配太多，内存存储数量过多，每次查找时间也会更长，阻塞 js 的执行；即使可以用并非，异步，空闲，分片等方式优化垃圾回收，但过大的内存分配，还是会在不合理的程序开发下造成问题；所以 V8 平衡考虑，没有必要分配更大的内存；

2. 怎么高效使用内存？
   在 V8 内存的限制条件下，我们怎么利用现有的内存呢？编写好 js 程序呢？
   我们思考，要更好的利用内存，也就是在不超出目前内存限制的条件下，让 V8 的垃圾回收机制能更高效的执行；
   也就是让我们手申请使用的内存数据，在程序不再使用的时候，尽快的被回收，及让这样内存数据对象脱离引用关系；

   - 变量的分配和释放：
     我们知道，V8 解析时，就会生成全局作用域，会开辟内存存放作用域内变量；局部函数作用域也会在执行时被创建分配内存，执行完后变量通常会被销毁，内存也会被释放；其实变量的会不会被清理也是看是否脱离了引用关系；
     全局作用域需要直到进程退出才能释放，这会导致对象的引用常驻内存（老生代中）；
     如果需要让老的对象脱离引用关系而被释放，可以使用 delete，或者重新赋值新对象；
     如我们可以赋值 null, undefined 来释放变量引用的对象；

     局部变量也可以使用如上方式让变量引用的对象脱离引用关系而释放；
     还有一个需要注意，闭包；在函数式编程（函数作为变量和返回值）的影响下，能让一个作用域的变量建立一个和另外一个作用域变量的引用关系；在这些变量很难被发现回收；

     总结起来就是：

     - 谨慎的创建全局变量，合理的删除引用关系（赋值 null 或 undefined 或 delete 属性，使用 delete 也要谨慎，以防影响 V8 的优化机制-如隐藏类，内联缓存）
     - 谨慎的使用闭包
     - 及时清理不需要的计时器对象引用或 Dom 对象引用等；

3. 内存的查看

   - process.memoryUsage() 查看 Node 进程的内存分配
     - rss 常驻内存
     - heapTatol V8 中的堆内存的总量
     - heapUsed V8 中的堆内存使用量
   - os 的 totalmem()和 freemem()查看的是操作系统的内存使用；

> 堆外内存：不通过 V8 分配的内存；

4. Node 需要关注的内存泄漏情况

- 缓存： 把内存当缓存使用；
  如 Node 模块由于模块的缓存机制，模块会常驻老生代，在设计模块时，防止模块中的无用变量或函数；
- 队列消费不及时；
  需要对队列进行监控和使用限制，防止队列无限制占用内存，让队列能更好的被调度起来；
- 作用域未释放；

5. 大内存该如何应用？
   Node 中应对大内存，我们可以 stream 的方式；stream 继承至 EventEmitter;
   如 fs.createReadStream(),fs.createWriteStream()...

   为什么可以使用流的方式来处理大文件呢？
   如读写流，它提供了管道方法 pipe；通过流的方式处理，不会受到 V8 堆内存限制的影响；

   其他方式：
   可以使用 Buffer 的方式操作字节，也不会受到 V8 堆内存的限制；
