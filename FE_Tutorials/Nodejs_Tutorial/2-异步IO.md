## 异步 I/O

#### 异步 I/O

1. 什么是异步？
   异步不用于阻塞和非阻塞，这是两个概念；们知道内核是只有阻塞和非阻塞的，并没有所谓的异步；
   所以异步是什么呢？  
   **异步是对于阻塞和非阻塞情况进行多线程管理，达到所谓异步的效果；**
   所以这里理解就是**异步的实现方案是基于多线程的；**

   延伸一下：
   这里其实还有一个问题我们需要注意，就是为什么会有阻塞和非阻塞之分；
   阻塞是我们很好理解，就一直干一件事，直到这个事做完；那非阻塞有有何用呢？
   这里的作用涉及另一个计算机基础，及 I/O 和 CPU 是可以并行的；

   反证一下，我们异步通常是做什么呢？不正是处理 I/O 吗？如果 I/O 和 CPU 在底层是不能并行的，我们的异步又又何用呢；

   > **异步 I/O 能实现的基础：I/O 和 CPU 是可以并行的；**

   接着说，异步的实现方案是基于多线程的；那异步的主体是什么呢？js 中，我们称之为事件的东西；我们把这些事件合理的管理，分配到线程，再合适的时机执行；
   所以进一步总结
   **异步的实现方案是基于事件机制和多线程；**

   了解了异步 I/O 是什么后，我们再看看为什么需要异步 I/O?

2. 为什么需要异步 I/O?

   - 从后端上来说：
     异步 I/O 可以合理的分配 CPU 和 I/O 的资源使用，提升利用率；
     同时也可以减少多个 I/O 操作的最后完成时间；类似于并行；（ps：这里讨论单线程的情况下）

   - 从前端上来说：
     异步可以很大程度上减少 UI 阻塞，提升用户体验；但前端资源获取的组素也取决于后端响应速度；

3. 异步 I/O 的实现原理？
   **异步的实现方案是基于事件机制和多线程；**
   以前有一些方案是基于轮训实现，实现方式太过于浪费 CPU；新的 I/O 实现机制利用了**事件通知，执行回调**的方式，然后利用**线程池**执行效率更高；

4. Node 的异步 I/O
   Node 的异步 I/O 主要分为 4 部分：

   - 事件循环：Node 自身的执行模型；

   - 观察者：
     判断是否有事件需要被处理的模式；

     > 事件循环是一个典型的生产者/消费者模型；异步 I/O，网络请求等则是事件的生产者，它们不断给 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理；

   - 请求对象：

     > 请求对象是异步 I/O 过程中的重要中间产物，所以的状态都保存在这个对象中，包括送入线程池等执行以及 I/O 操作完毕后的回调处理；

     简单来说，请求对象是执行信息，状态，以及回调函数的载体；一个请求对象随事件触发创建，之后穿梭于 Node 异步的各环节中，直到从请求对象中取除回调函数执行而消除；

   - 执行回调：

> Node 中异步一般分为两部分；第一部分是组装好请求对象，送入到线程池中等待执行；
> 第二步是执行回调，进行回调通知；

> Node 中 I/O 操作，不仅仅只限制于磁盘文件的读写；因为\*\*nix 将计算机的磁盘文件，硬件，套接字等几乎所有计算机资源都被抽象成了文件；

> 事件循环机制: https://zhuanlan.zhihu.com/p/33058983
