## 模块机制

1.  CommonJs 规范

    - 1.1 起因：  
      Js 自身**没有模块系统，没有标准接口，缺少标准库，缺乏包管理系统**的问题，及 Js 应用中基本没有自动加载和安装依赖的能力；
      为了处理 Js 没有标准的缺陷，设计了 CommonJs 规范，希望利用依据 CommonJs API 编写的应用具备**跨宿主环境执行的能力**，
      如下：

      - 服务器断 Js 应用程序
      - **命令行工具**
      - 客户端应用
      - 桌面图形界面应用程序
      - 混合应用...

      在 CommonJs 不断发展中，规范范围不断扩大，规范涵盖了**模块**，二进制，Buffer，字符集编码，I/O 流，进程环境，文件系统，套接字，单元测试，Web 服务器网关接口，**包管理**等

    - 1.2 CommonJs 的模块规范
      主要是对模块引用，模块定义，和模块标识这三部分定义；
      1）模块引用：

      ```
          var math= require('math');
      ```

      2)模块定义：
      模块提供 exports 对象用于当前模块方式或者变量的导出；
      （ps：模块还存在一个 module 对象，代表模块本身）

      ```
         // 方式一：
         exports={
             add:function(){ }
         }
         // 方式二：
         module.exports={
             add:function(){}
         }
      ```

      3)模块标识
      及传递给 require()方法的参数；  
       规则：**符合小驼峰命名的字符串，或者'./'，'../'开头的相对路径，或者/开头的绝对路径；** 可以没有文件名后缀.js；

      CommonJs 构建的这套模块导出和引入机制，使用户不必考虑变量污染，优于通过命民空间的方式处理变量污染；

    有了规范，接下来让我们看下 Node 的模块实现；

2.  Node 的模块实现  
     **在 Node 中，模块分为两类：核心模块（Node 提供的模块），文件模块（用户编写的模块，用户自定义模块也是属于文件模块）**

    要实现引用模块，需要经历 3 个步骤：

    - **路径分析**
    - **文件定位**
    - **编译执行**

    核心模块中，部分核心模块在 Node 进程启动时，就是以二进制的格式存储在内存中，所以这部分的核心模块在引入时，文件定位（ps：在路径解析时，直接对应了内存中的地址，直接在内存中读取，也就不需要文件定位）和编译执行（ps：已经是以二进制方式存储的）这个两个步骤可以省略，并且**在路径分析中优先判断**，所以**加载最快**；

    > ps：以上解释为什么核心模块加载最快;
    > 核心模块加载仅次于缓存加载；

    > **什么是缓存加载？** 缓存加载及 Node 机制中，类似于浏览器缓存静态文件机制，Node 也会缓存模块的引入，以减少二次引入时的开销；与浏览器缓存不同的是，Node 缓存是直接缓存编译和执行之后的对象；（缓存的是编译执行的结果；）

    文件模块是在运行时动态加载的，需要完整的 3 个步骤，比核心模块要慢；
    在文件模块中，对于自定义模块的路径分析会更为复杂，需要按照**模块路径的生成规则**来查找；

    > ps： 模块路径的生成规则： 从当前路径下开始，从下向上逐级递归查找 node_modules 目录下文件，直到根目录下 node_modules 目录；

    - 2.1 **路径分析：**
      及模块标识分析；
      1）分析区分核心模块，相对路径的文件模块（./,../），绝对路径的文件模块，自定义模块（需从 node_modules 中寻找）；

      2）核心模块  
       核心模块处理的优先级仅次于缓存加载；（及分析后，如果有缓存，则先处理缓存加载，之后就处理核心模块）；

      3）路径模块：（相对路径[.,..]和绝对路径模块[/]）
      路径分析时，会先将路径转化为**真实路径**；（ps：编译执行后缓存结果时，也是以该真实路径为 key，缓存到内存中）

      4）自定义模块
      通过**模块路径的生成规则**，一层层向外查找，找到文件路径；

    - 2.2 **文件定位：**
      对于文件定位，需要按有无文件拓展名来分析，并考虑目录和包的情况；

      - 有拓展名：
        直接匹配拓展名来定位；
      - 无拓展名 (!!!这里是考虑的重点)
        1）按'.js','.json','.node'的次序补全拓展名查找；

        > ps: 这里需要调用 fs 模块来判断文件是否存在，这时逻辑是同步阻塞的执行判读;

        2）[!!!]文件补全拓展名后找不到具体文件，却定位到了**目录文件**
        这个情况下，Node 会将此目录文件做为**包**处理；

        针对包的文件定位处理方式为如下：

        - 先查找是否存在 package.json 文件，存在则从找到文件中的 main 属性定位文件，没有 main 属性或 main 属性有误，则依次查询 index.js，index.json；
        - 无 package.json 文件，则也依次查询 index.js，index.json；
        - 还找不到，则抛出异常；

        > ps： **什么是包？** 包是 Node 管理模块和代码的一种方式；也是 CommonJs 规范的一部分；
        > CommomJs 包规范：如下 3. 包和 NPM

        > ps：所以当文件拓展名不是.js 时，补全拓展名，查找会更快；

    - 2.3 **编译执行**  
       编译执行主要针对.js，.json，.node 来处理；这里我们就先不谈.node 的处理；

      - 对 Js 模块的编译
        Node 对 Js 文件内容进行头尾包装，同时注入 require，exports， module.exports， `__dirname`，`__filename` 属性；
        这样每个模块之间就都进行了作用域隔离；
        具体如下：

        ```
            (
                function (require,exports, module.exports,__dirname,__filename){
                    // 模块代码
                }
            )
        ```

3.  包
    CommonJs 的包规范分为**包结构和包描述**两个部分；

    3.1） CommonJs 规范下的包结构：

        - package.json 包描述文件
        - bin 用于存放可执行二进制文件的目录
        - lib 用于存放 Js 代码的目录
        - doc 用于存放文档的目录
        - test 用于存放单元测试用例的代码

    3.2） 包描述 --- 及 package.json 文件
    包描述文件用于表达非代码相关的信息，它是一个 JSON 结构

4.  NPM
    NPM 是对 CommonJs 包规范的一个实践，CommonJs 包规范是理论基础； 同时是 Node 包管理器， 帮组弯沉第三方模块的发布，安装和依赖等；

    NPM 实践下，包描述的主要字段：

    - name 包名，规定有小写的字母和数字组成；
    - description 包简介
    - version 版本号
    - keywords 关键字词组，NPM 中主要用来做分类搜索
    - licenses 当前包的许可证列表
    - bin !!!全局执行安装后，可以将脚本添加到执行路径中，作为命令行工具的方式使用
    - main 包的模块默认入口文件；当没有配置或配置文件路径找不到时，会再依次查找 index.js,index.node,index.json；
    - scripts 脚本说明对象；主要被包管理器用来安装，编译，测试，卸载包等；
    - dependencies 使用当前包所需要依赖的包列表；NPM 通过这个属性自动加载依赖；
    - devDependencies 开发时，一些模块需要的依赖；
    - peerDependencies
    - repository
    - author 作者
    - os 操作系统支持列表
    - cpu CPU 架构的支持列表，如 arm，x86，x86_64
    - engines
    - ...

      4.1) 包安装
      包在安装的时候需要注意安装方式，

      - 全局安装：根据包描述文件的 bin 字段配置，将实际的脚本链接到与 Node 可执行文件相同的路径下

        npm install express -g 如

      ```
      "bin":{
          "express": "./bin/express"
      }
      ```

      - 局部安装
        npm install xxx

      - 设置镜像源安装
        自定义安装来源

        4.2) 发布包

      - 编写包模块代码和包描述
      - 注册包仓库账号
      - 上传包 npm publish <folder>

        4.3) 包权限的管理
        通过 npm owner 命令

        4.4）包的分析
        通过 npm ls 命令

        4.5)!!!包的质量检测和安全检测

5.  前后端共用模块

    前后端的 Js 分别处于 Http 的两端，位置不同，角色不同；对于服务器端的 Js，相同的代码，模块需要被执行多次，瓶颈在于 CPU 和内存等资源；浏览器端的 Js，则是需要从服务端分发到多个客户端执行，瓶颈是带宽；
    一个从磁盘加载，一个从网路加载，两者的加载速度不在一个数量级上；

    由于 Node 的模块引入过程，几乎全都是同步引入的；CommonJs 自定的规范不太适合前端应用场景，前端更希望能异步引入；

    所以参考 CommonJs 的规范，也出现了适合前端的模块加载规范；

    - AMD
      简单来说是依赖前置，异步加载

    - CMD
      简单来说是依赖就近、延迟执行

    > 这里 AMD 和 CMD 的 define 定义主要是为了作用域隔离。在 Node 中，Node 是默认通过隐式包装实现；包装模块，并传入 require，exports， module.exports...

    后期更多其他

    - UMD
    - ESM
