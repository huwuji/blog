## 设计模式

要说设计模式，我们先说一下设计模式的基本原则：
更细颗粒的抽象，更灵活的扩展和组合，更少的耦合和修改；
最重点关注：开闭原则，单一原则；

> SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）指代了面向对象编程(OOP)和面向对象设计(OOD)的五个基本原则;

- 单一原则(Single Responsibility Principle)
  简单地说就是一个类只做一件事；
  目的： 高内聚、低耦合。更细维度的抽象，更灵活的组合和复用；
  好处：（ps：这也是高内聚、低耦合的优势）
  1）类的功能更单一，也更清晰；
  2）更好的可读性，并带来更好的可维护性；
  3）低耦合带来的更好的可拓展性能；

- 里氏替换原则(Liskov Substitution Principle)
  简单地说子类可以扩展父类的功能，但不能改变父类原有的功能；
  里氏替换原则本质就是继承和多态的应用；
  如果说单一原则是指导从 0 到 1 的构建原则，那里斯替换可以说是规范从 1 到 n 的拓展原则；
  核心：支持扩展，警惕修改；

- 依赖倒置原则(Dependence Inversion Principle)
  简单地说面向接口编程，依赖于抽象而不依赖于具体实现；
  原则：
  1）上层模块不应该依赖底层模块，它们都应该依赖于抽象。
  2）抽象不应该依赖于细节，细节应该依赖于抽象。
  中间实现如果依赖太多‘中间层’，那耦合性也会增加，灵活性，可复用性也会增加；一但修改，维护性也会增加；

- 接口隔离原则(Interface Segregation Principle)
  简单地说是指导封装接口对外提供‘有用’接口原则；
  指导编程接口，收敛出口；提高内聚性；

- 开闭原则(Open-Close Principle)
  简单地说就是开发拓展，关闭修改；
  原则：一个软件实体类，模块和函数应该对扩展开放，对修改关闭。
  个人感觉是对以上原则的抽象；

### 一. 创建型模式 Creational Design Patterns

场景：适用于提供创建对象的事例中；
提供多样化的创建机制，提升已有代码的灵活性和复用性；

- 工厂模式
- 抽象工厂模式
- 生成器模式
- 原型模式
- 单例模式

### 二. 结构型模式 Structural Design Patterns

结构设计模式解释了如何将对象和类组装成更大的结构，同时保持这些结构的灵活性和效率；

> 复杂结构的设计，不仅有组合，还有分解抽象；

- 适配器模式：
  又称装器模式、Wrapper、Adapter
  能够转换对象接口， 使其能与其他对象进行交互；

  > 适配器更倾向于针对的是具体接口，也就是一个对象的某一个功能模块；

- 桥接模式：Bridge
  将一个大类或一组密切相关的类拆分为两个独立的层次结构（抽象和实现），它们可以彼此独立开发；

- 组合模式：
  又称：对象树、Object Tree、Composite
  将对象组合成树结构，然后像处理单个对象一样使用这些结构；

  > 逻辑和实现颗粒度更细致的拆分，同时约定匹配接口（通用，方便），能快捷组合；
  > 有点像乐高，堆积木；每一个都是一个单独的完整的个体，组合也能成一个完整的个体运行；

- 装饰模式：
  又称： 装饰者模式、装饰器模式、Wrapper、Decorator

  > 与适配器不同在于，适配器更倾向于针对的是具体接口，也就是一个对象的某一个功能模块；装饰器更倾向于对整个对象的包装，增强其功能，但是不改变其内部结构和外部调用规范；

- 外观模式：
  又称： Facade
  为库、框架或任何其他复杂的类集提供简化的接口；

  > 整合一系列小功能输出一个功能，并对外提供，屏蔽一系列内部操作。符合单一原则；

- 享元模式：
  又称： 缓存、Cache、Flyweight
  摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。

  > 数据层面的共用；内在也是数据载体的抽象，功能更单一的数据载体；

- 代理模式：
  又称：Proxy
  为另一个对象提供替代品或占位符，代理控制对原始对象的访问，允许在请求到达原始对象之前或之后执行某些操作；
  > node 代理，nginx 代理...
